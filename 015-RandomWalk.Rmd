# Random Walk Model {#randomWalk}

The *random walk* model is so simple that it's barely a model at all.
$$y_{t} = y_{t-1} + \epsilon_{t},\qquad\epsilon_{t} \sim N(0,\sigma_{\epsilon}^{2})$$
This says, "Today is like yesterday, only different."
Nonetheless, I find the model useful for exploring new time series data.
It answers the first basic question, how noisy is the data?

To estimate the model,
we first expand the definition into the state-space framework
expected by the software.

\begin{eqnarray*}
  y_{t} & = & \mu_{t} \\
  \mu_{t} & = & \mu_{t-1} + \xi_{t}, \qquad \xi_{t} \sim N(0,\sigma_{\xi}^{2})
\end{eqnarray*}

Notice that there is no error term in the first equation.
When we observe $y_{t}$, it's an uncorrupted copy of $\mu_{t}$.

The model has two parameters.

------------------  -------------------------------------------------
$\sigma_{\xi}^2$    Variance of the observational errors, $\xi_{t}$
$\mu_{0}$           Initial level of $\mu$
------------------  -------------------------------------------------

The R software always assumes that $y$ has an error term.
We get around that by forcing its variance to be zero,
effectively eliminating it.

## Fitting a Random Walk Model

### Problem {-}
You want to fit your time series data to a random walk model.

### Solution {-}
You can fit a random walk using the `StructTS` function.
Fit the data to a [local level model](#localLevel)
while forcing the observational variance to be zero.

```{r,eval=FALSE}
model <- StructTS(y, type="level", fixed=c(0, NA))
```

### Example {-}

```{r echo=TRUE, eval=TRUE}
y <- datasets::Nile

model <- StructTS(y, type="level", fixed=c(0, NA))
print(model)
```

### Discussion {-}

### Alt. Solution {-}

We can also fit a random walk using the dlm package.
The code for estimating parameters is very similar to
the code for the local level model.
The difference is that we force $V$, the variance of the observations,
to be zero.

We define a function, `buildRandomWalk`, that builds a `dlm` model object
from two input parameters, `dW` and `m0`.
The parameters are packed into a single, 2-element vector.

```{r, eval=FALSE}
buildRandomWalk <- function(v) {
  dW <- exp(v[1])
  m0 <- v[2]
  dlmModPoly(order=1, dV=0, dW=dW, m0=m0)
}
```

The function calls the `dlmModPoly` function from `dlm` to create the model object.

We need initial guesses for the model parameters.

```{r, eval=FALSE}
varGuess <- var(diff(y), na.rm=TRUE)
mu0Guess <- as.numeric(y[1])
```

Next we call the `dlmMLE` function to estimate the MLE parameters
using numerical optimzation.
Always check for convergence.

```{r, eval=FALSE}
parm <- c(log(varGuess), mu0Guess)
mle <- dlmMLE(y, parm=parm, buildRandomWalk)
if (mle$convergence != 0) stop(mle$message)
```

From the MLE estimates, we can build the final `dlm` model.

```{r, eval=FALSE}
model <- buildRandomWalk(mle$par)
```

We can extract the estimated parameters from `model`, the returned object.

---------- -----------------------------------
`model$W`  Variance of the random walk errors
`model$m0` Initial level
---------- -----------------------------------

### Alt. Example {-}

```{r, eval=TRUE}
library(dlm)

y <- datasets::Nile

buildRandomWalk <- function(v) {
  dW <- exp(v[1])
  m0 <- v[2]
  dlmModPoly(order=1, dV=0, dW=dW, m0=m0)
}

varGuess <- var(diff(y), na.rm=TRUE)
mu0Guess <- as.numeric(y[1])

parm <- c(log(varGuess), mu0Guess)
mle <- dlmMLE(y, parm=parm, buildRandomWalk)
if (mle$convergence != 0) stop("Optimizer did not converge")

model <- buildRandomWalk(mle$par)

cat("Transitional variance:", model$W, "\n",
    "Initial level:", model$m0, "\n")
```

### See Also {-}

## Diagnosing a Random Walk Model

### Problem {-}

### Solution {-}
The `tsdiag` function creates diagnostic plots
for models created using the `StructTS` function.

```{r eval=FALSE}
tsdiag(model)
```

### Example {-}

```{r echo=TRUE, eval=TRUE, fig.height=8}
y <- datasets::Nile

model <- StructTS(y, type="level", fixed=c(0, NA))
tsdiag(model)
```

### Discussion {-}

### Alt. Solution {-}

### See Also {-}

## Smoothing With a Random Walk Model

## Filtering With a Random Walk Model

## Plotting Filtered or Smoothed Results with a Random Walk Model

## Forecasting with a Random Walk Model

## Plotting Forecasted Values with a Random Walk Model
